Attempting to find the distances using MPC over the entire network faces many difficulties: Given our security assumptions, the computation can not publicly refer to the internal topology of the parties' networks. Thus, the number of nodes in each party network and their connections must be secretly shared as inputs to the computation as well as the initial distance ($0$ or $\infty$). This will add a huge communication cost, in addition to complicating the computation since it will operate on ``secret'' networks. This will be unpractical to implement for a variety of reasons, especially given networks of realistic sizes. \\

Even if we relax our security assumptions to allow leaking the number of nodes or similar information, running MPC on the whole network will still be unrealistic due to the size. The diameter of the whole network is unknown (unless if the parties reveal the internal connections between nodes), therefore we would have to use some lose upper bound (like the total number of nodes) as our number of iterations. This will cause the algorithm to use many more iterations than it has to, blowing it up to something close to $O(n^3)$ for dense networks. \\

We propose doing the computation in multiple stages. Each party will compute the distances of their own private networks (as if in isolation), in particular the distances of the gateway nodes, which will form the input to the MPC. This will greatly reduce the input of the MPC from the entire network to a smaller subset of nodes. Since the network connecting the gateways is public, we avoid the complications of secret sharing the network into the MPC, thus we can use Algorithm \ref{algo} described above for all stages of computation. \\

Our algorithm for computing the distances involves computing a min over the previous distance of the nodes and the distances of its neighbors (with 1 added since they are one edge away). This min is carried to the next iteration where it will serve as one of the arguments to another min. In particular, we will get one min per node per iteration, each of these mins has as many arguments as neighbors for a node. Performing min is expensive in MPC since it require performing comparisons without code-branching, since inspecting which instructions are executed will reveal the result of the comparison. \\

We propose to use symbolic values instead of secret shares initially. Executing the algorithm will cause the additions and minimums to be carried over ``symbolically'' throughout the iteration. Eventually yielding a single expression per node. These expressions are equivalent in size to the actual execution of the algorithm. We will then optimize these expressions to reduce the number of of min operators that are required. Eventually reducing the expression to a single min with many arguments. \\
